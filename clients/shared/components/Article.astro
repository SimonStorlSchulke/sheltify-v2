---
import { cms } from '@shared/cms/sheltify-access.ts';
import SectionRendererColumns from '@shared/components/sections/SectionRendererColumns.astro';
import RenderSectionAnimalList from 'article-renderer/components/RenderSectionAnimalList.svelte';
import type { CmsArticle, SectionType } from 'sheltify-lib/article-types.ts';
import RenderSectionTitle from 'article-renderer/components/RenderSectionTitle.svelte';
import RenderSectionText from 'article-renderer/components/RenderSectionText.svelte';
import RenderSectionImages from 'article-renderer/components/RenderSectionImages.svelte';
import RenderSectionHero from 'article-renderer/components/RenderSectionHero.svelte';
import RenderSectionForm from 'article-renderer/components/RenderSectionForm.svelte';
import "article-renderer/styles/_index.scss"
import { animalsByArticleId } from 'sheltify-lib/animal-util.ts';

interface Props {
  article: CmsArticle;
}

const { article } = Astro.props;

await populateDynamicData();

const fullWidthSections: SectionType[] = ['hero'];
let rowindex = 0;
const hasTopHero = article.Structure.Rows[0]?.SectionType == 'hero';
const topPadding = hasTopHero ? -16 : 48;
const cssClasses = ['themable', 'article', 'sui', 'flex-y'];

async function populateDynamicData() {
  for (const section of article.Structure.Rows) {
    switch (section.SectionType) {
      case 'animal-list':
        section.TempFoundAnimals = await cms.getFilteredAnimals(section.Content);
        break;
      case 'image':
          section.Content.MediaFiles = await cms.getMediaFilesByIds(section.Content.MediaFiles.map(i => i.ID));
    }
  }
}

const allAnimalsByArticle = animalsByArticleId(await cms.animals);

---
<div style={'margin-top: ' + topPadding + 'px'} class:list={cssClasses}>

{
  article.Structure.Rows.map(section =>
    {
      // if a hero is the first row, we need negate of the initial top padding so it's placed right below the header
      const isTopHero = rowindex == 0 && section.SectionType == 'hero';
      rowindex++;
      const isFullWidth = fullWidthSections.includes(section.SectionType);
      const isFullWidthAndPadding = section.SectionType == 'columns' && section.Content.FullWidth;
        let comp;
        switch (section.SectionType) {
          case 'text':
            comp = <RenderSectionText section={section}/>;
            break;
          case 'title':
            comp = <RenderSectionTitle section={section}/>
            break;
          case 'separator-x':
            comp = <hr/>;
            break;
          case 'hero':
            comp = <RenderSectionHero section={section} client:visible/>;
            break;
          case 'animal-list':
            comp = <RenderSectionAnimalList section={section} allAnimalsByArticle={allAnimalsByArticle}/>;
            break;
          case 'image':
            comp = <RenderSectionImages section={section} client:visible/>;
            break;
          case 'columns':
            comp = <SectionRendererColumns section={section}/>;
            break;
          case 'form':
            comp = <RenderSectionForm section={section} submitUrl={cms.formSubmitUrl} client:load/>;
            break;
          case 'html':
            comp = <div set:html={section.Content.Html}/>;
            break;
          default:
            comp = <div>Sektionstyp nicht unterst√ºtzt</div>;
            break;
          }
      return <div class={`row section-${section.SectionType}` + (isFullWidth ? ' full-width' : '') + (isFullWidthAndPadding ? ' full-width full-width-padding' : '')}>{comp}</div>
      }
    )
  }
</div>

<style is:global lang="scss">
  .article {
    gap: var(--section-gap-y);
    .row {
      &:not(.full-width) {
        width: var(--wrapper-width);
        max-width: 100%;
        margin-left: auto;
        margin-right: auto;
      }

      &.full-width-padding {
        width: 100%;
        padding: calc(var(--padding-article) / 2);
      }
    }


  }
</style>
